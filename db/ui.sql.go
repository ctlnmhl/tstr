// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: ui.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const uIListRecentRuns = `-- name: UIListRecentRuns :many
SELECT runs.id, runs.test_id, runs.test_run_config_id, runs.runner_id, runs.result, runs.logs, runs.scheduled_at, runs.started_at, runs.finished_at, tests.name as test_name, tests.labels, test_run_configs.container_image, test_run_configs.command, test_run_configs.args, test_run_configs.env, test_run_configs.created_at, runners.name AS runner_name, (finished_at is NULL)::bool AS is_pending
FROM runs
JOIN test_run_configs ON runs.test_run_config_id = test_run_configs.id
JOIN runners ON runs.runner_id = runners.id
JOIN tests on runs.test_id = tests.id
ORDER BY is_pending, runs.started_at DESC
LIMIT $1
`

type UIListRecentRunsRow struct {
	ID              uuid.UUID
	TestID          uuid.UUID
	TestRunConfigID uuid.UUID
	RunnerID        uuid.NullUUID
	Result          RunResult
	Logs            pgtype.JSONB
	ScheduledAt     sql.NullTime
	StartedAt       sql.NullTime
	FinishedAt      sql.NullTime
	TestName        string
	Labels          pgtype.JSONB
	ContainerImage  string
	Command         sql.NullString
	Args            []string
	Env             pgtype.JSONB
	CreatedAt       sql.NullTime
	RunnerName      string
	IsPending       bool
}

func (q *Queries) UIListRecentRuns(ctx context.Context, db DBTX, limit int32) ([]UIListRecentRunsRow, error) {
	rows, err := db.Query(ctx, uIListRecentRuns, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UIListRecentRunsRow
	for rows.Next() {
		var i UIListRecentRunsRow
		if err := rows.Scan(
			&i.ID,
			&i.TestID,
			&i.TestRunConfigID,
			&i.RunnerID,
			&i.Result,
			&i.Logs,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.FinishedAt,
			&i.TestName,
			&i.Labels,
			&i.ContainerImage,
			&i.Command,
			&i.Args,
			&i.Env,
			&i.CreatedAt,
			&i.RunnerName,
			&i.IsPending,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uIListTests = `-- name: UIListTests :many
select id, name, labels, cron_schedule, next_run_at, registered_at, updated_at, archived_at from tests
`

func (q *Queries) UIListTests(ctx context.Context, db DBTX) ([]Test, error) {
	rows, err := db.Query(ctx, uIListTests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Test
	for rows.Next() {
		var i Test
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Labels,
			&i.CronSchedule,
			&i.NextRunAt,
			&i.RegisteredAt,
			&i.UpdatedAt,
			&i.ArchivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uITestResults = `-- name: UITestResults :many
SELECT test_id,array_agg(result) AS results FROM runs where test_id is not null GROUP BY test_id
`

type UITestResultsRow struct {
	TestID  uuid.UUID
	Results interface{}
}

func (q *Queries) UITestResults(ctx context.Context, db DBTX) ([]UITestResultsRow, error) {
	rows, err := db.Query(ctx, uITestResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UITestResultsRow
	for rows.Next() {
		var i UITestResultsRow
		if err := rows.Scan(&i.TestID, &i.Results); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uITestsByLabels = `-- name: UITestsByLabels :many
SELECT labels, array_agg(tests.id) AS tests FROM tests WHERE labels IN (SELECT DISTINCT(labels) FROM tests) GROUP BY labels
`

type UITestsByLabelsRow struct {
	Labels pgtype.JSONB
	Tests  interface{}
}

func (q *Queries) UITestsByLabels(ctx context.Context, db DBTX) ([]UITestsByLabelsRow, error) {
	rows, err := db.Query(ctx, uITestsByLabels)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UITestsByLabelsRow
	for rows.Next() {
		var i UITestsByLabelsRow
		if err := rows.Scan(&i.Labels, &i.Tests); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
