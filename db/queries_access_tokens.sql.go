// Code generated by pggen. DO NOT EDIT.

package db

import (
	"context"
	"fmt"
	"github.com/jackc/pgx/v4"
	"time"
)

const issueAccessTokenSQL = `INSERT INTO access_tokens (name, token_hash, scopes)
VALUES ($1, $2, $3)
RETURNING id, name, scopes, issued_at, expires_at, revoked_at;`

type IssueAccessTokenParams struct {
	Name      string
	TokenHash string
	Scopes    []AccessTokenScope
}

type IssueAccessTokenRow struct {
	ID        string             `json:"id"`
	Name      string             `json:"name"`
	Scopes    []AccessTokenScope `json:"scopes"`
	IssuedAt  time.Time          `json:"issued_at"`
	ExpiresAt time.Time          `json:"expires_at"`
	RevokedAt time.Time          `json:"revoked_at"`
}

// IssueAccessToken implements Querier.IssueAccessToken.
func (q *DBQuerier) IssueAccessToken(ctx context.Context, params IssueAccessTokenParams) (IssueAccessTokenRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "IssueAccessToken")
	row := q.conn.QueryRow(ctx, issueAccessTokenSQL, params.Name, params.TokenHash, q.types.newAccessTokenScopeArrayInit(params.Scopes))
	var item IssueAccessTokenRow
	scopesArray := q.types.newAccessTokenScopeArray()
	if err := row.Scan(&item.ID, &item.Name, scopesArray, &item.IssuedAt, &item.ExpiresAt, &item.RevokedAt); err != nil {
		return item, fmt.Errorf("query IssueAccessToken: %w", err)
	}
	if err := scopesArray.AssignTo(&item.Scopes); err != nil {
		return item, fmt.Errorf("assign IssueAccessToken row: %w", err)
	}
	return item, nil
}

// IssueAccessTokenBatch implements Querier.IssueAccessTokenBatch.
func (q *DBQuerier) IssueAccessTokenBatch(batch genericBatch, params IssueAccessTokenParams) {
	batch.Queue(issueAccessTokenSQL, params.Name, params.TokenHash, q.types.newAccessTokenScopeArrayInit(params.Scopes))
}

// IssueAccessTokenScan implements Querier.IssueAccessTokenScan.
func (q *DBQuerier) IssueAccessTokenScan(results pgx.BatchResults) (IssueAccessTokenRow, error) {
	row := results.QueryRow()
	var item IssueAccessTokenRow
	scopesArray := q.types.newAccessTokenScopeArray()
	if err := row.Scan(&item.ID, &item.Name, scopesArray, &item.IssuedAt, &item.ExpiresAt, &item.RevokedAt); err != nil {
		return item, fmt.Errorf("scan IssueAccessTokenBatch row: %w", err)
	}
	if err := scopesArray.AssignTo(&item.Scopes); err != nil {
		return item, fmt.Errorf("assign IssueAccessToken row: %w", err)
	}
	return item, nil
}

const getAccessTokenSQL = `SELECT id, name, scopes, issued_at, expires_at, revoked_at
FROM access_tokens
WHERE id = $1::uuid;`

type GetAccessTokenRow struct {
	ID        string             `json:"id"`
	Name      string             `json:"name"`
	Scopes    []AccessTokenScope `json:"scopes"`
	IssuedAt  time.Time          `json:"issued_at"`
	ExpiresAt time.Time          `json:"expires_at"`
	RevokedAt time.Time          `json:"revoked_at"`
}

// GetAccessToken implements Querier.GetAccessToken.
func (q *DBQuerier) GetAccessToken(ctx context.Context, id string) (GetAccessTokenRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetAccessToken")
	row := q.conn.QueryRow(ctx, getAccessTokenSQL, id)
	var item GetAccessTokenRow
	scopesArray := q.types.newAccessTokenScopeArray()
	if err := row.Scan(&item.ID, &item.Name, scopesArray, &item.IssuedAt, &item.ExpiresAt, &item.RevokedAt); err != nil {
		return item, fmt.Errorf("query GetAccessToken: %w", err)
	}
	if err := scopesArray.AssignTo(&item.Scopes); err != nil {
		return item, fmt.Errorf("assign GetAccessToken row: %w", err)
	}
	return item, nil
}

// GetAccessTokenBatch implements Querier.GetAccessTokenBatch.
func (q *DBQuerier) GetAccessTokenBatch(batch genericBatch, id string) {
	batch.Queue(getAccessTokenSQL, id)
}

// GetAccessTokenScan implements Querier.GetAccessTokenScan.
func (q *DBQuerier) GetAccessTokenScan(results pgx.BatchResults) (GetAccessTokenRow, error) {
	row := results.QueryRow()
	var item GetAccessTokenRow
	scopesArray := q.types.newAccessTokenScopeArray()
	if err := row.Scan(&item.ID, &item.Name, scopesArray, &item.IssuedAt, &item.ExpiresAt, &item.RevokedAt); err != nil {
		return item, fmt.Errorf("scan GetAccessTokenBatch row: %w", err)
	}
	if err := scopesArray.AssignTo(&item.Scopes); err != nil {
		return item, fmt.Errorf("assign GetAccessToken row: %w", err)
	}
	return item, nil
}

const listAccessTokensSQL = `SELECT id, name, scopes, issued_at, expires_at, revoked_at
FROM access_tokens
WHERE
  CASE WHEN $1
   THEN expires_at IS NOT NULL
   ELSE TRUE
  END AND
  CASE WHEN $2
   THEN revoked_at IS NOT NULL
   ELSE TRUE
  END;`

type ListAccessTokensRow struct {
	ID        string             `json:"id"`
	Name      string             `json:"name"`
	Scopes    []AccessTokenScope `json:"scopes"`
	IssuedAt  time.Time          `json:"issued_at"`
	ExpiresAt time.Time          `json:"expires_at"`
	RevokedAt time.Time          `json:"revoked_at"`
}

// ListAccessTokens implements Querier.ListAccessTokens.
func (q *DBQuerier) ListAccessTokens(ctx context.Context, filterExpired bool, filterRevoked bool) ([]ListAccessTokensRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ListAccessTokens")
	rows, err := q.conn.Query(ctx, listAccessTokensSQL, filterExpired, filterRevoked)
	if err != nil {
		return nil, fmt.Errorf("query ListAccessTokens: %w", err)
	}
	defer rows.Close()
	items := []ListAccessTokensRow{}
	scopesArray := q.types.newAccessTokenScopeArray()
	for rows.Next() {
		var item ListAccessTokensRow
		if err := rows.Scan(&item.ID, &item.Name, scopesArray, &item.IssuedAt, &item.ExpiresAt, &item.RevokedAt); err != nil {
			return nil, fmt.Errorf("scan ListAccessTokens row: %w", err)
		}
		if err := scopesArray.AssignTo(&item.Scopes); err != nil {
			return nil, fmt.Errorf("assign ListAccessTokens row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListAccessTokens rows: %w", err)
	}
	return items, err
}

// ListAccessTokensBatch implements Querier.ListAccessTokensBatch.
func (q *DBQuerier) ListAccessTokensBatch(batch genericBatch, filterExpired bool, filterRevoked bool) {
	batch.Queue(listAccessTokensSQL, filterExpired, filterRevoked)
}

// ListAccessTokensScan implements Querier.ListAccessTokensScan.
func (q *DBQuerier) ListAccessTokensScan(results pgx.BatchResults) ([]ListAccessTokensRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query ListAccessTokensBatch: %w", err)
	}
	defer rows.Close()
	items := []ListAccessTokensRow{}
	scopesArray := q.types.newAccessTokenScopeArray()
	for rows.Next() {
		var item ListAccessTokensRow
		if err := rows.Scan(&item.ID, &item.Name, scopesArray, &item.IssuedAt, &item.ExpiresAt, &item.RevokedAt); err != nil {
			return nil, fmt.Errorf("scan ListAccessTokensBatch row: %w", err)
		}
		if err := scopesArray.AssignTo(&item.Scopes); err != nil {
			return nil, fmt.Errorf("assign ListAccessTokens row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListAccessTokensBatch rows: %w", err)
	}
	return items, err
}
