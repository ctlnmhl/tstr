// Code generated by pggen. DO NOT EDIT.

package db

import (
	"context"
	"fmt"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const registerTestSQL = `WITH data (name, labels, cron_schedule, container_image, command, args, env) AS (
  VALUES (
    $1::varchar,
    $2::jsonb,
    $3::varchar,
    $4::varchar,
    $5::varchar,
    $6::varchar[],
    $7::jsonb
  )
), test AS (
  INSERT INTO tests (name, labels, cron_schedule)
  SELECT name, labels, cron_schedule
  FROM data
  RETURNING id, name, labels, cron_schedule, registered_at, updated_at
), test_run_config AS (
  INSERT INTO test_run_configs (test_id, container_image, command, args, env)
  SELECT test.id, container_image, command, args, env
  FROM data, test
  RETURNING id AS test_run_config_version, container_image, command, args, env, created_at AS test_run_config_created_at
)
SELECT * FROM test, test_run_config;`

type RegisterTestParams struct {
	Name           string
	Labels         pgtype.JSONB
	CronSchedule   string
	ContainerImage string
	Command        string
	Args           []string
	Env            pgtype.JSONB
}

type RegisterTestRow struct {
	ID                     string             `json:"id"`
	Name                   string             `json:"name"`
	Labels                 pgtype.JSONB       `json:"labels"`
	CronSchedule           string             `json:"cron_schedule"`
	RegisteredAt           pgtype.Timestamptz `json:"registered_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	TestRunConfigVersion   string             `json:"test_run_config_version"`
	ContainerImage         string             `json:"container_image"`
	Command                string             `json:"command"`
	Args                   []string           `json:"args"`
	Env                    pgtype.JSONB       `json:"env"`
	TestRunConfigCreatedAt pgtype.Timestamptz `json:"test_run_config_created_at"`
}

// RegisterTest implements Querier.RegisterTest.
func (q *DBQuerier) RegisterTest(ctx context.Context, params RegisterTestParams) (RegisterTestRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "RegisterTest")
	row := q.conn.QueryRow(ctx, registerTestSQL, params.Name, params.Labels, params.CronSchedule, params.ContainerImage, params.Command, params.Args, params.Env)
	var item RegisterTestRow
	if err := row.Scan(&item.ID, &item.Name, &item.Labels, &item.CronSchedule, &item.RegisteredAt, &item.UpdatedAt, &item.TestRunConfigVersion, &item.ContainerImage, &item.Command, &item.Args, &item.Env, &item.TestRunConfigCreatedAt); err != nil {
		return item, fmt.Errorf("query RegisterTest: %w", err)
	}
	return item, nil
}

// RegisterTestBatch implements Querier.RegisterTestBatch.
func (q *DBQuerier) RegisterTestBatch(batch genericBatch, params RegisterTestParams) {
	batch.Queue(registerTestSQL, params.Name, params.Labels, params.CronSchedule, params.ContainerImage, params.Command, params.Args, params.Env)
}

// RegisterTestScan implements Querier.RegisterTestScan.
func (q *DBQuerier) RegisterTestScan(results pgx.BatchResults) (RegisterTestRow, error) {
	row := results.QueryRow()
	var item RegisterTestRow
	if err := row.Scan(&item.ID, &item.Name, &item.Labels, &item.CronSchedule, &item.RegisteredAt, &item.UpdatedAt, &item.TestRunConfigVersion, &item.ContainerImage, &item.Command, &item.Args, &item.Env, &item.TestRunConfigCreatedAt); err != nil {
		return item, fmt.Errorf("scan RegisterTestBatch row: %w", err)
	}
	return item, nil
}

const getTestSQL = `SELECT tests.*, test_run_configs.id AS test_run_config_version, container_image, command, args, env, created_at
FROM tests
JOIN test_run_configs
ON tests.id = test_run_configs.test_id
WHERE tests.id = $1::uuid
ORDER BY test_run_configs.created_at DESC
LIMIT 1;`

type GetTestRow struct {
	ID                   string             `json:"id"`
	Name                 string             `json:"name"`
	Labels               pgtype.JSONB       `json:"labels"`
	CronSchedule         string             `json:"cron_schedule"`
	RegisteredAt         pgtype.Timestamptz `json:"registered_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	ArchivedAt           pgtype.Timestamptz `json:"archived_at"`
	TestRunConfigVersion string             `json:"test_run_config_version"`
	ContainerImage       string             `json:"container_image"`
	Command              string             `json:"command"`
	Args                 []string           `json:"args"`
	Env                  pgtype.JSONB       `json:"env"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
}

// GetTest implements Querier.GetTest.
func (q *DBQuerier) GetTest(ctx context.Context, id string) (GetTestRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetTest")
	row := q.conn.QueryRow(ctx, getTestSQL, id)
	var item GetTestRow
	if err := row.Scan(&item.ID, &item.Name, &item.Labels, &item.CronSchedule, &item.RegisteredAt, &item.UpdatedAt, &item.ArchivedAt, &item.TestRunConfigVersion, &item.ContainerImage, &item.Command, &item.Args, &item.Env, &item.CreatedAt); err != nil {
		return item, fmt.Errorf("query GetTest: %w", err)
	}
	return item, nil
}

// GetTestBatch implements Querier.GetTestBatch.
func (q *DBQuerier) GetTestBatch(batch genericBatch, id string) {
	batch.Queue(getTestSQL, id)
}

// GetTestScan implements Querier.GetTestScan.
func (q *DBQuerier) GetTestScan(results pgx.BatchResults) (GetTestRow, error) {
	row := results.QueryRow()
	var item GetTestRow
	if err := row.Scan(&item.ID, &item.Name, &item.Labels, &item.CronSchedule, &item.RegisteredAt, &item.UpdatedAt, &item.ArchivedAt, &item.TestRunConfigVersion, &item.ContainerImage, &item.Command, &item.Args, &item.Env, &item.CreatedAt); err != nil {
		return item, fmt.Errorf("scan GetTestBatch row: %w", err)
	}
	return item, nil
}

const listTestsSQL = `SELECT tests.*, latest_configs.id AS test_run_config_version, latest_configs.container_image, latest_configs.command, latest_configs.args, latest_configs.env, latest_configs.created_at
FROM tests
JOIN test_run_configs AS latest_configs
ON tests.id = latest_configs.test_id
LEFT JOIN test_run_configs
ON test_run_configs.test_id = latest_configs.test_id AND latest_configs.created_at > test_run_configs.created_at
WHERE test_run_configs IS NULL AND tests.labels @> $1::jsonb
ORDER BY tests.name ASC;`

type ListTestsRow struct {
	ID                   string             `json:"id"`
	Name                 string             `json:"name"`
	Labels               pgtype.JSONB       `json:"labels"`
	CronSchedule         string             `json:"cron_schedule"`
	RegisteredAt         pgtype.Timestamptz `json:"registered_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	ArchivedAt           pgtype.Timestamptz `json:"archived_at"`
	TestRunConfigVersion string             `json:"test_run_config_version"`
	ContainerImage       string             `json:"container_image"`
	Command              string             `json:"command"`
	Args                 []string           `json:"args"`
	Env                  pgtype.JSONB       `json:"env"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
}

// ListTests implements Querier.ListTests.
func (q *DBQuerier) ListTests(ctx context.Context, labels pgtype.JSONB) ([]ListTestsRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ListTests")
	rows, err := q.conn.Query(ctx, listTestsSQL, labels)
	if err != nil {
		return nil, fmt.Errorf("query ListTests: %w", err)
	}
	defer rows.Close()
	items := []ListTestsRow{}
	for rows.Next() {
		var item ListTestsRow
		if err := rows.Scan(&item.ID, &item.Name, &item.Labels, &item.CronSchedule, &item.RegisteredAt, &item.UpdatedAt, &item.ArchivedAt, &item.TestRunConfigVersion, &item.ContainerImage, &item.Command, &item.Args, &item.Env, &item.CreatedAt); err != nil {
			return nil, fmt.Errorf("scan ListTests row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListTests rows: %w", err)
	}
	return items, err
}

// ListTestsBatch implements Querier.ListTestsBatch.
func (q *DBQuerier) ListTestsBatch(batch genericBatch, labels pgtype.JSONB) {
	batch.Queue(listTestsSQL, labels)
}

// ListTestsScan implements Querier.ListTestsScan.
func (q *DBQuerier) ListTestsScan(results pgx.BatchResults) ([]ListTestsRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query ListTestsBatch: %w", err)
	}
	defer rows.Close()
	items := []ListTestsRow{}
	for rows.Next() {
		var item ListTestsRow
		if err := rows.Scan(&item.ID, &item.Name, &item.Labels, &item.CronSchedule, &item.RegisteredAt, &item.UpdatedAt, &item.ArchivedAt, &item.TestRunConfigVersion, &item.ContainerImage, &item.Command, &item.Args, &item.Env, &item.CreatedAt); err != nil {
			return nil, fmt.Errorf("scan ListTestsBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListTestsBatch rows: %w", err)
	}
	return items, err
}

const updateTestSQL = `UPDATE tests
SET
  name = $1::varchar,
  labels = $2::jsonb,
  cron_schedule = $3::varchar,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $4::uuid;`

type UpdateTestParams struct {
	Name         string
	Labels       pgtype.JSONB
	CronSchedule string
	ID           string
}

// UpdateTest implements Querier.UpdateTest.
func (q *DBQuerier) UpdateTest(ctx context.Context, params UpdateTestParams) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "UpdateTest")
	cmdTag, err := q.conn.Exec(ctx, updateTestSQL, params.Name, params.Labels, params.CronSchedule, params.ID)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query UpdateTest: %w", err)
	}
	return cmdTag, err
}

// UpdateTestBatch implements Querier.UpdateTestBatch.
func (q *DBQuerier) UpdateTestBatch(batch genericBatch, params UpdateTestParams) {
	batch.Queue(updateTestSQL, params.Name, params.Labels, params.CronSchedule, params.ID)
}

// UpdateTestScan implements Querier.UpdateTestScan.
func (q *DBQuerier) UpdateTestScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec UpdateTestBatch: %w", err)
	}
	return cmdTag, err
}

const createTestRunConfigSQL = `INSERT INTO test_run_configs (container_image, command, args, env)
VALUES (
  $1::varchar,
  $2::varchar,
  $3::varchar[],
  $4::jsonb
)
RETURNING *;`

type CreateTestRunConfigParams struct {
	ContainerImage string
	Command        string
	Args           []string
	Env            pgtype.JSONB
}

type CreateTestRunConfigRow struct {
	ID             string             `json:"id"`
	TestID         string             `json:"test_id"`
	ContainerImage string             `json:"container_image"`
	Command        string             `json:"command"`
	Args           []string           `json:"args"`
	Env            pgtype.JSONB       `json:"env"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
}

// CreateTestRunConfig implements Querier.CreateTestRunConfig.
func (q *DBQuerier) CreateTestRunConfig(ctx context.Context, params CreateTestRunConfigParams) (CreateTestRunConfigRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "CreateTestRunConfig")
	row := q.conn.QueryRow(ctx, createTestRunConfigSQL, params.ContainerImage, params.Command, params.Args, params.Env)
	var item CreateTestRunConfigRow
	if err := row.Scan(&item.ID, &item.TestID, &item.ContainerImage, &item.Command, &item.Args, &item.Env, &item.CreatedAt); err != nil {
		return item, fmt.Errorf("query CreateTestRunConfig: %w", err)
	}
	return item, nil
}

// CreateTestRunConfigBatch implements Querier.CreateTestRunConfigBatch.
func (q *DBQuerier) CreateTestRunConfigBatch(batch genericBatch, params CreateTestRunConfigParams) {
	batch.Queue(createTestRunConfigSQL, params.ContainerImage, params.Command, params.Args, params.Env)
}

// CreateTestRunConfigScan implements Querier.CreateTestRunConfigScan.
func (q *DBQuerier) CreateTestRunConfigScan(results pgx.BatchResults) (CreateTestRunConfigRow, error) {
	row := results.QueryRow()
	var item CreateTestRunConfigRow
	if err := row.Scan(&item.ID, &item.TestID, &item.ContainerImage, &item.Command, &item.Args, &item.Env, &item.CreatedAt); err != nil {
		return item, fmt.Errorf("scan CreateTestRunConfigBatch row: %w", err)
	}
	return item, nil
}

const archiveTestSQL = `UPDATE tests
SET archived_at = CURRENT_TIMESTAMP
WHERE id = $1::uuid;`

// ArchiveTest implements Querier.ArchiveTest.
func (q *DBQuerier) ArchiveTest(ctx context.Context, id string) (pgconn.CommandTag, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ArchiveTest")
	cmdTag, err := q.conn.Exec(ctx, archiveTestSQL, id)
	if err != nil {
		return cmdTag, fmt.Errorf("exec query ArchiveTest: %w", err)
	}
	return cmdTag, err
}

// ArchiveTestBatch implements Querier.ArchiveTestBatch.
func (q *DBQuerier) ArchiveTestBatch(batch genericBatch, id string) {
	batch.Queue(archiveTestSQL, id)
}

// ArchiveTestScan implements Querier.ArchiveTestScan.
func (q *DBQuerier) ArchiveTestScan(results pgx.BatchResults) (pgconn.CommandTag, error) {
	cmdTag, err := results.Exec()
	if err != nil {
		return cmdTag, fmt.Errorf("exec ArchiveTestBatch: %w", err)
	}
	return cmdTag, err
}
