// Code generated by pggen. DO NOT EDIT.

package db

import (
	"context"
	"fmt"
	"github.com/jackc/pgtype"
	"github.com/jackc/pgx/v4"
)

const registerRunnerSQL = `INSERT INTO runners (name, accept_test_label_selectors, reject_test_label_selectors, last_heartbeat_at)
VALUES (
  $1,
  $2,
  $3,
  CURRENT_TIMESTAMP
)
RETURNING *;`

type RegisterRunnerParams struct {
	Name                     string
	AcceptTestLabelSelectors pgtype.JSONB
	RejectTestLabelSelectors pgtype.JSONB
}

type RegisterRunnerRow struct {
	ID                       string             `json:"id"`
	Name                     string             `json:"name"`
	AcceptTestLabelSelectors pgtype.JSONB       `json:"accept_test_label_selectors"`
	RejectTestLabelSelectors pgtype.JSONB       `json:"reject_test_label_selectors"`
	RegisteredAt             pgtype.Timestamptz `json:"registered_at"`
	LastHeartbeatAt          pgtype.Timestamptz `json:"last_heartbeat_at"`
}

// RegisterRunner implements Querier.RegisterRunner.
func (q *DBQuerier) RegisterRunner(ctx context.Context, params RegisterRunnerParams) (RegisterRunnerRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "RegisterRunner")
	row := q.conn.QueryRow(ctx, registerRunnerSQL, params.Name, params.AcceptTestLabelSelectors, params.RejectTestLabelSelectors)
	var item RegisterRunnerRow
	if err := row.Scan(&item.ID, &item.Name, &item.AcceptTestLabelSelectors, &item.RejectTestLabelSelectors, &item.RegisteredAt, &item.LastHeartbeatAt); err != nil {
		return item, fmt.Errorf("query RegisterRunner: %w", err)
	}
	return item, nil
}

// RegisterRunnerBatch implements Querier.RegisterRunnerBatch.
func (q *DBQuerier) RegisterRunnerBatch(batch genericBatch, params RegisterRunnerParams) {
	batch.Queue(registerRunnerSQL, params.Name, params.AcceptTestLabelSelectors, params.RejectTestLabelSelectors)
}

// RegisterRunnerScan implements Querier.RegisterRunnerScan.
func (q *DBQuerier) RegisterRunnerScan(results pgx.BatchResults) (RegisterRunnerRow, error) {
	row := results.QueryRow()
	var item RegisterRunnerRow
	if err := row.Scan(&item.ID, &item.Name, &item.AcceptTestLabelSelectors, &item.RejectTestLabelSelectors, &item.RegisteredAt, &item.LastHeartbeatAt); err != nil {
		return item, fmt.Errorf("scan RegisterRunnerBatch row: %w", err)
	}
	return item, nil
}

const getRunnerSQL = `SELECT *
FROM runners
WHERE id = $1;`

type GetRunnerRow struct {
	ID                       string             `json:"id"`
	Name                     string             `json:"name"`
	AcceptTestLabelSelectors pgtype.JSONB       `json:"accept_test_label_selectors"`
	RejectTestLabelSelectors pgtype.JSONB       `json:"reject_test_label_selectors"`
	RegisteredAt             pgtype.Timestamptz `json:"registered_at"`
	LastHeartbeatAt          pgtype.Timestamptz `json:"last_heartbeat_at"`
}

// GetRunner implements Querier.GetRunner.
func (q *DBQuerier) GetRunner(ctx context.Context, id string) (GetRunnerRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "GetRunner")
	row := q.conn.QueryRow(ctx, getRunnerSQL, id)
	var item GetRunnerRow
	if err := row.Scan(&item.ID, &item.Name, &item.AcceptTestLabelSelectors, &item.RejectTestLabelSelectors, &item.RegisteredAt, &item.LastHeartbeatAt); err != nil {
		return item, fmt.Errorf("query GetRunner: %w", err)
	}
	return item, nil
}

// GetRunnerBatch implements Querier.GetRunnerBatch.
func (q *DBQuerier) GetRunnerBatch(batch genericBatch, id string) {
	batch.Queue(getRunnerSQL, id)
}

// GetRunnerScan implements Querier.GetRunnerScan.
func (q *DBQuerier) GetRunnerScan(results pgx.BatchResults) (GetRunnerRow, error) {
	row := results.QueryRow()
	var item GetRunnerRow
	if err := row.Scan(&item.ID, &item.Name, &item.AcceptTestLabelSelectors, &item.RejectTestLabelSelectors, &item.RegisteredAt, &item.LastHeartbeatAt); err != nil {
		return item, fmt.Errorf("scan GetRunnerBatch row: %w", err)
	}
	return item, nil
}

const listRunnersSQL = `SELECT *
FROM runners
WHERE last_heartbeat_at > $1;`

type ListRunnersRow struct {
	ID                       string             `json:"id"`
	Name                     string             `json:"name"`
	AcceptTestLabelSelectors pgtype.JSONB       `json:"accept_test_label_selectors"`
	RejectTestLabelSelectors pgtype.JSONB       `json:"reject_test_label_selectors"`
	RegisteredAt             pgtype.Timestamptz `json:"registered_at"`
	LastHeartbeatAt          pgtype.Timestamptz `json:"last_heartbeat_at"`
}

// ListRunners implements Querier.ListRunners.
func (q *DBQuerier) ListRunners(ctx context.Context, heartbeatSince pgtype.Timestamptz) ([]ListRunnersRow, error) {
	ctx = context.WithValue(ctx, "pggen_query_name", "ListRunners")
	rows, err := q.conn.Query(ctx, listRunnersSQL, heartbeatSince)
	if err != nil {
		return nil, fmt.Errorf("query ListRunners: %w", err)
	}
	defer rows.Close()
	items := []ListRunnersRow{}
	for rows.Next() {
		var item ListRunnersRow
		if err := rows.Scan(&item.ID, &item.Name, &item.AcceptTestLabelSelectors, &item.RejectTestLabelSelectors, &item.RegisteredAt, &item.LastHeartbeatAt); err != nil {
			return nil, fmt.Errorf("scan ListRunners row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListRunners rows: %w", err)
	}
	return items, err
}

// ListRunnersBatch implements Querier.ListRunnersBatch.
func (q *DBQuerier) ListRunnersBatch(batch genericBatch, heartbeatSince pgtype.Timestamptz) {
	batch.Queue(listRunnersSQL, heartbeatSince)
}

// ListRunnersScan implements Querier.ListRunnersScan.
func (q *DBQuerier) ListRunnersScan(results pgx.BatchResults) ([]ListRunnersRow, error) {
	rows, err := results.Query()
	if err != nil {
		return nil, fmt.Errorf("query ListRunnersBatch: %w", err)
	}
	defer rows.Close()
	items := []ListRunnersRow{}
	for rows.Next() {
		var item ListRunnersRow
		if err := rows.Scan(&item.ID, &item.Name, &item.AcceptTestLabelSelectors, &item.RejectTestLabelSelectors, &item.RegisteredAt, &item.LastHeartbeatAt); err != nil {
			return nil, fmt.Errorf("scan ListRunnersBatch row: %w", err)
		}
		items = append(items, item)
	}
	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("close ListRunnersBatch rows: %w", err)
	}
	return items, err
}
